/* A simple CUP parser based on JFlex lexer for R language.*/
/*
    DEVELOPERS :
    https://github.com/Nikronic, https://github.com/erfanMhi

*/

package cup.example;

/* importing CUP library */
import java_cup.runtime.*;
import cup.example.Lexer;
import java.io.IOException;
import java.io.File;
import java.io.FileInputStream;

/* Connect this parser to a scanner! */
parser code {:
  protected Lexer lexer;
:}

/* define how to connect to the scanner! */
init with {:
  ComplexSymbolFactory f = new ComplexSymbolFactory();
  symbolFactory = f;
  File file = new File("input.txt");
  FileInputStream fis = null;
  try {
    fis = new FileInputStream(file);
  } catch (IOException e) {
    e.printStackTrace();
  } 
  lexer = new Lexer(f,fis);
:};
scan with {: return lexer.next_token(); :};
/* Terminals (tokens returned by the scanner). */
terminal IF, ELSE, FOR,FUNCTION, IN; /* keywords */
terminal COMMA, LPAR, RPAR, BEGIN, END, ASSIGN, COLON; /* symbols */
terminal PLUS, MINUS, MULT,DIV; /* calculation operators */
terminal LEQ, GTQ, EQ, NEQ, LE, GT; /* comparetors */
terminal AND, OR, NOT; /* boolean operators */
terminal IDENT;
terminal Integer INTCONST;
terminal Float FLOATCONST;
terminal Boolean BOOLCONST;
terminal String STRINGCONST;
terminal COMMENTS;  /*identifiers and variables */

/* Nonterminals (other terms to reach to Terminals). */
non terminal        program,program_util;
non terminal 		if_condition;
non terminal 		else_condition;
non terminal 		function_def_section;
non terminal 		argument,argument_next,call_argument,call_argument_next;
non terminal 		call_function;
non terminal		logic_statement;
non terminal 		numerical_literal;
non terminal 		comparison_ops;
non terminal		math_calculation;
non terminal 		numerical_op;
non terminal 		binary_calculation;
non terminal	    calculation;
non terminal 		loop_section;
non terminal		code_section;
non terminal        command_list;
non terminal        op_assignment;
non terminal        int_literal;
non terminal        operand;


precedence left PLUS, MINUS;
precedence left MULT, DIV;


program ::= program_util  {: System.out.println("Code Root Found"); :}
		;

program_util ::= function_def_section program_util 
				| call_function 
				|
			;
			
function_def_section ::= IDENT ASSIGN FUNCTION argument BEGIN code_section END {: System.out.println("Function Implementation Found"); :}
			;
			
argument	::= LPAR IDENT argument_next
			| LPAR RPAR
			;
			
argument_next ::= COMMA IDENT argument_next | RPAR
			;
			
code_section  ::= op_assignment code_section
			| call_function code_section
			| if_condition code_section
			| loop_section code_section	
			|
			;
			
op_assignment ::= IDENT:v ASSIGN calculation:ex  {: System.out.println( v + " variable Assigned. "); :}
				;

/* function_call	::=	IDENT LPAR STRINGCONST RPAR
			; */

if_condition	::= IF LPAR logic_statement RPAR BEGIN code_section END else_condition {: System.out.println("If Entry Found"); :}
			;
			

else_condition	::= ELSE BEGIN code_section END  {: System.out.println("Else Entry Found"); :}
			| /* empty */
			;
			
loop_section	::= FOR LPAR IDENT IN int_literal COLON int_literal RPAR BEGIN code_section END {: System.out.println("Loop Entry Found"); :}
				;

call_function ::= IDENT:e call_argument {: System.out.println("Function " + e + " Called"); :}
				;
				
call_argument	::= LPAR operand call_argument_next
			| LPAR RPAR
			;
			
call_argument_next ::= COMMA operand call_argument_next | RPAR
			;


numerical_literal ::= INTCONST:e 
					| FLOATCONST:e
					;

int_literal ::= INTCONST:e 
			| IDENT
			;

numerical_op ::= numerical_literal:e {: RESULT = e; :}
		| IDENT
		;
	
operand ::= numerical_op |
			STRINGCONST
			;
		
logic_statement ::= numerical_op comparison_ops numerical_op
				;
					
comparison_ops	::= LEQ
				| GTQ
				| EQ
				| NEQ
				| LE
				| GT
				;
				
math_calculation ::= numerical_op:e1 PLUS math_calculation:e2 
				| numerical_op:e1 MINUS math_calculation:e2 
				| numerical_op:e1 MULT math_calculation:e2
				| numerical_op:e1 DIV math_calculation:e2 
				| numerical_op:e {: RESULT = e; :}
				;	
				


binary_calculation ::= BOOLCONST OR binary_calculation
					| BOOLCONST AND binary_calculation
					| NOT binary_calculation
					| BOOLCONST
					;
calculation ::= math_calculation:e {: RESULT = e; :} 
			| binary_calculation
			;	
